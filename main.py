# ========= Agent helpers =========

from typing import Dict, Any, List, Optional
from datetime import datetime, timezone

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ø¨Ø± Environment Ù„Ø§Ø­Ù‚Ù‹Ø§
RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", "0.01"))      # 1% Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§
DEFAULT_RR      = float(os.getenv("DEFAULT_RR", "1.5"))          # Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ù„Ù„Ø¹Ø§Ø¦Ø¯
MAIN_REF        = os.getenv("MAIN_REF_SYMBOL", "SPCUSD")         # Ù…Ø±Ø¬Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„ (SPC)

# Ø°Ø§ÙƒØ±Ø© Ù‚ØµÙŠØ±Ø© Ù„Ø­ÙØ¸ Ø¢Ø®Ø± Ø§Ù„ØªÙˆØµÙŠØ§Øª (ØªØ¹Ø±Ø¶ ÙÙŠ /report)
RECENT_SIGNALS: List[Dict[str, Any]] = []

def _now_iso() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

def _float(x: Any) -> Optional[float]:
    try:
        return float(x)
    except Exception:
        return None

def base_rules(alert: Alert) -> Dict[str, Any]:
    """
    Ù‚ÙˆØ§Ø¹Ø¯ Ø®ÙÙŠÙØ© ØªÙˆÙ„Ù‘Ø¯ Ø§ØªØ¬Ø§Ù‡ ÙˆØ«Ù‚Ø© Ù…Ø¨Ù†ÙŠØ© Ø¹Ù„Ù‰:
    - Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‚Ø§Ø¯Ù… Ù…Ù† TradingView (BUY/SELL Ø£Ùˆ signal Ø¹Ø§Ù…)
    - Ø³ÙŠØ§Ù‚ Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ø±Ø¬Ø¹ÙŠ SPC Ø¥Ø°Ø§ ÙˆØµÙ„ØªÙ†Ø§ Ø¥Ø´Ø§Ø±Ø§ØªÙ‡ (Ù…Ù† Ø¢Ø®Ø± RECENT_SIGNALS)
    - ÙØ±ÙŠÙ… Ø§Ù„Ø¥Ø´Ø§Ø±Ø©
    """
    symbol = (alert.symbol or "").upper()
    direction = None
    confidence = 50

    # 1) Ù…Ù† TradingView â€” Ù„Ùˆ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ØµØ±ÙŠØ­Ø© (BUY/SELL)
    raw = (alert.type or "").lower()
    if "buy" in raw:
        direction = "LONG"
        confidence = 60
    elif "sell" in raw:
        direction = "SHORT"
        confidence = 60

    # 2) ØªØ­ÙŠØ² Ù…Ø±Ø¬Ø¹ÙŠ Ù…Ù† SPC Ø¥Ø°Ø§ ØªÙˆÙØ± Ø¢Ø®Ø± Ø§ØªØ¬Ø§Ù‡ Ù„Ù‡
    def last_dir(sym: str) -> Optional[str]:
        for r in reversed(RECENT_SIGNALS):
            if r.get("symbol") == sym:
                return r.get("direction")
        return None

    spc_dir = last_dir(MAIN_REF)
    if spc_dir:
        # Ù„Ùˆ Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„ÙŠØ³ SPCØŒ Ù†Ø¹Ø²Ø²/Ù†Ø®ÙÙ‘Ø¶ Ø§Ù„Ø«Ù‚Ø© Ø­Ø³Ø¨ ØªÙˆØ§ÙÙ‚Ù‡ Ù…Ø¹Ù‡
        if symbol != MAIN_REF and direction:
            if (spc_dir == "LONG" and direction == "LONG") or (spc_dir == "SHORT" and direction == "SHORT"):
                confidence += 10
            else:
                confidence -= 10

    # 3) fallback: Ù„Ùˆ Ù…Ø§ÙÙŠÙ‡ Ø§ØªØ¬Ø§Ù‡ ÙˆØ§Ø¶Ø­ØŒ Ù†Ø¹Ø·ÙŠ "Neutral" Ø¨Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©
    if not direction:
        direction = "NEUTRAL"
        confidence = 40

    # 4) Ù‚Øµ Ø§Ù„Ø«Ù‚Ø© Ù„Ù…Ø¯Ù‰ [10..90]
    confidence = max(10, min(90, confidence))

    return {"direction": direction, "confidence": confidence}

def risk_plan(alert: Alert, rules: Dict[str, Any]) -> Dict[str, Any]:
    """
    ØªÙˆÙ„ÙŠØ¯ Ø®Ø·Ø© ØªØ¯Ø§ÙˆÙ„ Ø±Ù‚Ù…ÙŠØ© Ø³Ø±ÙŠØ¹Ø©:
    - Ø§Ù„Ø¯Ø®ÙˆÙ„ = Ø³Ø¹Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø­Ø§Ù„ÙŠ
    - Ø§Ù„ÙˆÙ‚Ù = 0.35% Ø¹ÙƒØ³ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)
    - Ø§Ù„Ù‡Ø¯Ù = RR * Ø§Ù„Ù…Ø³Ø§ÙØ©
    """
    price = _float(alert.price)
    if price is None or price <= 0:
        return {"entry": None, "sl": None, "tp": None, "rr": DEFAULT_RR}

    direction = rules["direction"]
    rr = DEFAULT_RR
    stop_pct = 0.0035  # 0.35% Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§

    if direction == "LONG":
        sl = price * (1 - stop_pct)
        tp = price + (price - sl) * rr
    elif direction == "SHORT":
        sl = price * (1 + stop_pct)
        tp = price - (sl - price) * rr
    else:
        sl = None
        tp = None

    return {"entry": price, "sl": sl, "tp": tp, "rr": rr}

def build_recommendation(alert: Alert) -> Dict[str, Any]:
    rules = base_rules(alert)
    plan  = risk_plan(alert, rules)

    rec = {
        "ts": _now_iso(),
        "symbol": (alert.symbol or "").upper(),
        "interval": alert.interval,
        "direction": rules["direction"],
        "confidence": rules["confidence"],
        "entry": plan["entry"],
        "sl": plan["sl"],
        "tp": plan["tp"],
        "rr": plan["rr"],
        "note": "Auto-generated by Agent v1 (rules-based)."
    }
    return rec

def fmt_telegram_table(rec: Dict[str, Any]) -> str:
    def f(x, d=2):
        return f"{x:.{d}f}" if isinstance(x, (int, float)) else "-"
    lines = [
        f"ğŸ“ˆ *{rec['symbol']}*  |  â± {rec.get('interval','-')}  |  {rec['ts']}",
        f"â€¢ Direction: *{rec['direction']}*  |  Confidence: *{rec['confidence']}%*",
        f"â€¢ Entry: *{f(rec['entry'])}*  |  SL: *{f(rec['sl'])}*  |  TP: *{f(rec['tp'])}*  |  RR: {rec['rr']}",
        f"â€¢ Note: {rec['note']}"
    ]
    return "\n".join(lines)

async def send_to_telegram(text: str) -> None:
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode": "Markdown"}
    try:
        async with httpx.AsyncClient(timeout=10) as client:
            await client.post(url, json=payload)
    except Exception:
        pass

